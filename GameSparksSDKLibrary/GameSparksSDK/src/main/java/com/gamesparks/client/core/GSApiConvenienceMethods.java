package com.gamesparks.client.core;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * GameSparks service API convenience methods.
 * <p/>
 * This class is auto-generated by the GameSparks Code Generation Engine based on the service request classes and should not be modified as changes will not be
 * maintained when the class is regenerated. Extend this class or one of its children if you wish change or enhance it.
 * 
 * @author GameSparks Code Generation Engine
 * 
 */
public abstract class GSApiConvenienceMethods extends GSApi {

    /**
     * Accepts a challenge that has been issued to the current player.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender acceptChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".AcceptChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Retrieves the details of the current authenticated player.
     * 
     */
    public GSSender accountDetailsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".AccountDetailsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Records some custom analytical data.
     * <p/>
     * Simple analytics, where you just need to track the number of times something happened, just take a key parameter. We'll record the players id against the
     * data to allow you to report on averages per user
     * <p/>
     * Timed analytics allow you to send start and end timer requests, and with this data GameSparks can track the length of time something takes.
     * <p/>
     * If an end request is sent without a matching start timer the request will fail silently and your analytics data might not contain what you expect.
     * <p/>
     * If both start and end are supplied, the request will be treated as a start timer.
     * <p/>
     * An additional data payload can be attached to the event for advanced reporting. This data can be a string, number or JSON object.
     * <p/>
     * If a second start timer is created using a key that has already had a start timer created without an end, the previous one will be marked as abandoned.
     * 
     * @param data Custom data payload
     * @param end Use the value true to indicate it's a end timer
     * @param key The key you want to track this analysis with.
     * @param start Use the value true to indicate it's a start timer
     */
    public GSSender analyticsRequest(Map data, Boolean end, String key, Boolean start) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".AnalyticsRequest", apiParamData);
        setApiParamData("data", data, apiParamData);
        setApiParamData("end", end, apiParamData);
        setApiParamData("key", key, apiParamData);
        setApiParamData("start", start, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns leaderboard data that is adjacent to the currently signed in player's position within the given leaderboard.
     * 
     * @param count
     * @param friendIds
     * @param leaderboardShortCode
     * @param social
     */
    public GSSender aroundMeLeaderboardRequest(Integer count, String[] friendIds, String leaderboardShortCode, boolean social) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".AroundMeLeaderboardRequest", apiParamData);
        setApiParamData("count", count, apiParamData);
        setApiParamData("friendIds", friendIds, apiParamData);
        setApiParamData("leaderboardShortCode", leaderboardShortCode, apiParamData);
        setApiParamData("social", social, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Provides authentication using a username/password combination.
     * <p/>
     * The username will have been previously created using a RegistrationRequest.
     * 
     * @param password The previously registered password
     * @param userName The previously registered player name
     */
    public GSSender authenticationRequest(String password, String userName) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".AuthenticationRequest", apiParamData);
        setApiParamData("password", password, apiParamData);
        setApiParamData("userName", userName, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Purchases a virtual good with an in game currency. Once purchased the virtual good will be added to the players account.
     * 
     * @param currencyType Which virtual currency to use
     * @param quantity The number of items to purchase
     * @param shortCode The short code of the virtual good to be purchased
     */
    public GSSender buyVirtualGoodsRequest(Integer currencyType, Long quantity, String shortCode) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".BuyVirtualGoodsRequest", apiParamData);
        setApiParamData("currencyType", currencyType, apiParamData);
        setApiParamData("quantity", quantity, apiParamData);
        setApiParamData("shortCode", shortCode, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Change the display name of the currently signed in Player.
     * 
     * @param displayName
     */
    public GSSender changeUserDetailsRequest(String displayName) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ChangeUserDetailsRequest", apiParamData);
        setApiParamData("displayName", displayName, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Sends a message to all players involved in the challenge. The current player must be involved in the challenge for the message to be sent.
     * <p/>
     * As the message is sent to all players, the current player will also see details of the message in the response. Read the section on response message
     * aggregation for a description of this.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender chatOnChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ChatOnChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Consumes a given amount of the specified virtual good.
     * 
     * @param quantity
     * @param shortCode
     */
    public GSSender consumeVirtualGoodRequest(Long quantity, String shortCode) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ConsumeVirtualGoodRequest", apiParamData);
        setApiParamData("quantity", quantity, apiParamData);
        setApiParamData("shortCode", shortCode, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Issues a challenge to a group of players form the currently signed in player
     * 
     * @param accessType
     * @param challengeMessage
     * @param challengeShortCode
     * @param currency1Wager
     * @param currency2Wager
     * @param currency3Wager
     * @param currency4Wager
     * @param currency5Wager
     * @param currency6Wager
     * @param endTime
     * @param expiryTime
     * @param maxAttempts
     * @param maxPlayers
     * @param minPlayers
     * @param startTime
     * @param usersToChallenge
     */
    public GSSender createChallengeRequest(String accessType, String challengeMessage, String challengeShortCode, Long currency1Wager, Long currency2Wager,
            Long currency3Wager, Long currency4Wager, Long currency5Wager, Long currency6Wager, Date endTime, Date expiryTime, Long maxAttempts,
            Long maxPlayers, Long minPlayers, Date startTime, String[] usersToChallenge) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".CreateChallengeRequest", apiParamData);
        setApiParamData("accessType", accessType, apiParamData);
        setApiParamData("challengeMessage", challengeMessage, apiParamData);
        setApiParamData("challengeShortCode", challengeShortCode, apiParamData);
        setApiParamData("currency1Wager", currency1Wager, apiParamData);
        setApiParamData("currency2Wager", currency2Wager, apiParamData);
        setApiParamData("currency3Wager", currency3Wager, apiParamData);
        setApiParamData("currency4Wager", currency4Wager, apiParamData);
        setApiParamData("currency5Wager", currency5Wager, apiParamData);
        setApiParamData("currency6Wager", currency6Wager, apiParamData);
        setApiParamData("endTime", endTime, apiParamData);
        setApiParamData("expiryTime", expiryTime, apiParamData);
        setApiParamData("maxAttempts", maxAttempts, apiParamData);
        setApiParamData("maxPlayers", maxPlayers, apiParamData);
        setApiParamData("minPlayers", minPlayers, apiParamData);
        setApiParamData("startTime", startTime, apiParamData);
        setApiParamData("usersToChallenge", usersToChallenge, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Declines a challenge that has been issued to the current player.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender declineChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".DeclineChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a device id to be used to create an anonymous profile in the game.
     * <p/>
     * This allows the player to be tracked and have data stored against them before using FacebookConnectRequest to create a full profile.
     * <p/>
     * DeviceAuthenticationRequest should not be used in conjunction with RegistrationRequest as the two accounts will not be merged.
     * 
     * @param deviceId A unique device identifier. Each platform has it's own method for getting a unique id
     * @param deviceModel
     * @param deviceName
     * @param deviceOS An indicator of the device platform, should be ios, android or wp8
     * @param deviceType
     * @param operatingSystem
     */
    public GSSender deviceAuthenticationRequest(String deviceId, String deviceModel, String deviceName, String deviceOS, String deviceType,
            String operatingSystem) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".DeviceAuthenticationRequest", apiParamData);
        setApiParamData("deviceId", deviceId, apiParamData);
        setApiParamData("deviceModel", deviceModel, apiParamData);
        setApiParamData("deviceName", deviceName, apiParamData);
        setApiParamData("deviceOS", deviceOS, apiParamData);
        setApiParamData("deviceType", deviceType, apiParamData);
        setApiParamData("operatingSystem", operatingSystem, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a message to be dismissed. Once dismissed the message will no longer appear in either ListMessageResponse or ListMessageSummaryResponse.
     * 
     * @param messageId The messageId of the message to dismiss
     */
    public GSSender dismissMessageRequest(String messageId) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".DismissMessageRequest", apiParamData);
        setApiParamData("messageId", messageId, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Records the end of the current users active session.
     * <p/>
     * The SDK will automatically create a new session ID when the app is started, this method can be useful to call when the app goes into the background to
     * allow reporting on player session length.
     * 
     */
    public GSSender endSessionRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".EndSessionRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows either a Facebook access token, or a Facebook authorization code to be used as an authentication mechanism.
     * <p/>
     * Once authenticated the platform can determine the current players details from the Facebook platform and store them within GameSparks.
     * <p/>
     * GameSparks will determine the player's friends and whether any of them are currently registered with the game.
     * <p/>
     * If the Facebook user is already linked to a player, the current session will switch to the linked player.
     * <p/>
     * If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Facebook user is not
     * already registered with the game, the Facebook user will be linked to the current player.
     * <p/>
     * If the current player has not authenticated and the Facebook user is not known, a new player will be created using the Facebook details and the session
     * will be authenticated against the new player.
     * <p/>
     * If the Facebook user is already known, the session will switch to being the previously created user.
     * 
     * @param accessToken The access token is used by the client to make authenticated requests on behalf of the end user.
     * @param code An authorization code is a short-lived token representing the user's access grant, created by the authorization server and passed to the
     *            client application via the browser.
     */
    public GSSender facebookConnectRequest(String accessToken, String code) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".FacebookConnectRequest", apiParamData);
        setApiParamData("accessToken", accessToken, apiParamData);
        setApiParamData("code", code, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Issues a challenge to a group of players form the currently signed in player
     * 
     * @param accessType
     * @param count
     * @param offset
     */
    public GSSender findChallengeRequest(String accessType, int count, int offset) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".FindChallengeRequest", apiParamData);
        setApiParamData("accessType", accessType, apiParamData);
        setApiParamData("count", count, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Gets the details of a challenge. The current player must be involved in the challenge for the request to succeed.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender getChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a secure, time sensitive url to allow the game to download a piece of downloadable content stored in the GameSparks platform.
     * 
     * @param shortCode The short code of the Downloadable item
     */
    public GSSender getDownloadableRequest(String shortCode) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetDownloadableRequest", apiParamData);
        setApiParamData("shortCode", shortCode, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the full details of a message.
     * 
     * @param messageId The messageId of the message retreive
     */
    public GSSender getMessageRequest(String messageId) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetMessageRequest", apiParamData);
        setApiParamData("messageId", messageId, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Get the aggregation data for a group of the player's friends given running total specified by short code.
     * 
     * @param friendIds
     * @param shortCode
     */
    public GSSender getRunningTotalsRequest(String[] friendIds, String shortCode) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetRunningTotalsRequest", apiParamData);
        setApiParamData("friendIds", friendIds, apiParamData);
        setApiParamData("shortCode", shortCode, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a secure, time sensitive URL to allow the game to upload a piece of player content to the GameSparks platform.
     * 
     * @param uploadData
     */
    public GSSender getUploadUrlRequest(Map uploadData) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetUploadUrlRequest", apiParamData);
        setApiParamData("uploadData", uploadData, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a secure, time sensitive URL to a piece of content that was previously uploaded to the GameSparks platform by a player.
     * 
     * @param uploadId
     */
    public GSSender getUploadedRequest(String uploadId) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GetUploadedRequest", apiParamData);
        setApiParamData("uploadId", uploadId, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Processes the response from a Google Play in app purchase flow.
     * <p/>
     * The GameSparks platform will validate the signature and signed data with the Google Play Public Key configured against the game.
     * <p/>
     * The orderId in the data will be recorded and the request will be rejected if the orderId has previously been processed, this prevents replay attacks.
     * <p/>
     * Once verfied, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up
     * by matching the productId in the signed data with the 'Google Product ID' configured against the virtual good.
     * <p/>
     * It's critical that the signedData is sent exactly as it is returned form google, including any whitespace. Any modification of the signedData will cause
     * the verification process to fail.
     * 
     * @param currencyCode
     * @param signature The value obtained from data.getStringExtra("INAPP_DATA_SIGNATURE");
     * @param signedData The value obtained from data.getStringExtra("INAPP_PURCHASE_DATA")
     * @param subUnitPrice
     */
    public GSSender googlePlayBuyGoodsRequest(String currencyCode, String signature, String signedData, Long subUnitPrice) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".GooglePlayBuyGoodsRequest", apiParamData);
        setApiParamData("currencyCode", currencyCode, apiParamData);
        setApiParamData("signature", signature, apiParamData);
        setApiParamData("signedData", signedData, apiParamData);
        setApiParamData("subUnitPrice", subUnitPrice, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Processes a transaction receipt from an App Store in app purchase.
     * <p/>
     * The GameSparks platform will validate the receipt with Apple and process the response. The transaction_id in the response will be recorded and the
     * request will be rejected if the transaction_id has previously been processed, this prevents replay attacks.
     * <p/>
     * Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up
     * by matching the product_id in the response with the 'IOS Product ID' configured against the virtual good.
     * 
     * @param currencyCode
     * @param receipt The reciept obtained from SKPaymentTransaction. transactionReceipt
     * @param sandbox
     * @param subUnitPrice
     */
    public GSSender iOSBuyGoodsRequest(String currencyCode, String receipt, Boolean sandbox, Long subUnitPrice) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".IOSBuyGoodsRequest", apiParamData);
        setApiParamData("currencyCode", currencyCode, apiParamData);
        setApiParamData("receipt", receipt, apiParamData);
        setApiParamData("sandbox", sandbox, apiParamData);
        setApiParamData("subUnitPrice", subUnitPrice, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Processes a transaction receipt from an App Store in app purchase.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender joinChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".JoinChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the top data for either the specified global leaderboard or the specified challenges leaderboard. The data is sorted as defined in the rules
     * specified in the leaderboard configuration.
     * <p/>
     * The response contains the top of the leaderboard, and returns the number of entries as defined in the entryCount parameter.
     * <p/>
     * If a shortCode is supplied, the response will contain the global leaderboard data. If a challengeInstanceId is supplied, the response will contain the
     * leaderboard data for the challenge.
     * 
     * @param challengeInstanceId The challenge instance to get the leaderboard data for
     * @param entryCount The maximum number of records to return
     * @param friendIds
     * @param leaderboardShortCode The short code of the leaderboard
     * @param offset
     * @param social
     */
    public GSSender leaderboardDataRequest(String challengeInstanceId, Integer entryCount, String[] friendIds, String leaderboardShortCode, Integer offset,
            boolean social) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".LeaderboardDataRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("entryCount", entryCount, apiParamData);
        setApiParamData("friendIds", friendIds, apiParamData);
        setApiParamData("leaderboardShortCode", leaderboardShortCode, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        setApiParamData("social", social, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Retrieves a list of the configured achievements in the game, along with whether the current player has earned the achievement.
     * 
     */
    public GSSender listAchievementsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListAchievementsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a list of challenges in the state defined in the 'state' field.
     * <p/>
     * The response can be further filtered by passing a shortCode field which will limit the returned lists to challenges of that short code.
     * <p/>
     * Valid states are:
     * <p/>
     * WAITING : The challenge has been issued and accepted and is waiting for the start date.
     * <p/>
     * RUNNING : The challenge is active.
     * <p/>
     * ISSUED : The challenge has been issued by the current player and is waiting to be accepted.
     * <p/>
     * RECEIVED : The challenge has been issued to the current player and is waiting to be accepted.
     * <p/>
     * COMPLETE : The challenge has completed.
     * <p/>
     * DECLINED : The challenge has been issued by the current player and has been declined.
     * 
     * @param entryCount The number of items to return in a page (default=50)
     * @param offset The offset (page number) to start from (default=0)
     * @param shortCode The type of challenge to return
     * @param state The state of the challenged to be returned
     */
    public GSSender listChallengeRequest(int entryCount, int offset, String shortCode, String state) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListChallengeRequest", apiParamData);
        setApiParamData("entryCount", entryCount, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        setApiParamData("shortCode", shortCode, apiParamData);
        setApiParamData("state", state, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the list of configured challenge types.
     * 
     */
    public GSSender listChallengeTypeRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListChallengeTypeRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the list of the current players game friends.
     * <p/>
     * A Game friend is someone in their social network who also plays the game.
     * <p/>
     * Against each friend, and indicator is supplied to show whether the friend is currently connected to the GameSparks service
     * 
     */
    public GSSender listGameFriendsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListGameFriendsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the list of the current players game friends.
     * <p/>
     * A Game friend is someone in their social network who also plays the game.
     * 
     */
    public GSSender listInviteFriendsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListInviteFriendsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a list of all leaderboards configured in the game.
     * 
     */
    public GSSender listLeaderboardsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListLeaderboardsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the list of the current players messages / notifications.
     * <p/>
     * The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest Read the section on Messages to the the complete list of
     * messages and their meaning.
     * 
     * @param entryCount The number of items to return in a page (default=50)
     * @param offset The offset (page number) to start from (default=0)
     */
    public GSSender listMessageRequest(int entryCount, int offset) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListMessageRequest", apiParamData);
        setApiParamData("entryCount", entryCount, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns a summary of the list of the current players messages / notifications.
     * <p/>
     * The list only contains un-dismissed messages, to dismiss a message see DismissMessageRequest.
     * <p/>
     * The full message can be retrieved using GetMessageRequest Read the section on Messages to see the complete list of messages and their meanings.
     * 
     * @param entryCount The number of items to return in a page (default=50)
     * @param offset The offset (page number) to start from (default=0)
     */
    public GSSender listMessageSummaryRequest(int entryCount, int offset) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListMessageSummaryRequest", apiParamData);
        setApiParamData("entryCount", entryCount, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns the list of configured virtual goods.
     * 
     */
    public GSSender listVirtualGoodsRequest() {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".ListVirtualGoodsRequest", apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a user defined event to be triggered. The event will be posted to the challenge specified.
     * <p/>
     * This call differs from most as it does not have a fixed format. The @class, challengeInstanceId and eventKey attributes are common, but the rest of the
     * attributes are as defined in the Event object configured in the dev portal.
     * <p/>
     * The example below shows a request to en event with a short code of HS with 2 attributes, 'HS' & 'GL'
     * 
     * @param challengeInstanceId The ID challenge instance to target
     * @param eventKey The short code of the event to trigger
     */
    public GSSender logChallengeEventRequest(String challengeInstanceId, String eventKey) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".LogChallengeEventRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("eventKey", eventKey, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a user defined event to be triggered.
     * <p/>
     * This call differs from most as it does not have a fixed format. The @class and eventKey attributes are common, but the rest of the attributes are as
     * defined in the Event object configured in the dev portal.
     * <p/>
     * The example below shows a request to an event with a short code of HS with 2 attributes, 'HS' & 'GL'
     * 
     * @param eventKey The short code of the event to trigger
     */
    public GSSender logEventRequest(String eventKey) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".LogEventRequest", apiParamData);
        setApiParamData("eventKey", eventKey, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Registers the current device for push notifications. Currently GameSparks supports iOS, GCM & Microsoft Push notifications.
     * <p/>
     * Supply the device type, and the push notification identifier for the device.
     * 
     * @param deviceOS The type of id, valid values are ios, android or wp8
     * @param pushId The push notification identifier for the device
     */
    public GSSender pushRegistrationRequest(String deviceOS, String pushId) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".PushRegistrationRequest", apiParamData);
        setApiParamData("deviceOS", deviceOS, apiParamData);
        setApiParamData("pushId", pushId, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a new user to be created using with a username, password and (optional) display name.
     * 
     * @param displayName A display name to use
     * @param password The previously registered password
     * @param userName The previously registered player name
     */
    public GSSender registrationRequest(String displayName, String password, String userName) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".RegistrationRequest", apiParamData);
        setApiParamData("displayName", displayName, apiParamData);
        setApiParamData("password", password, apiParamData);
        setApiParamData("userName", userName, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Sends a message to one or more game friend(s). A game friend is someone in the players social network who also plays the game.
     * 
     * @param friendIds
     * @param message
     */
    public GSSender sendFriendMessageRequest(String[] friendIds, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".SendFriendMessageRequest", apiParamData);
        setApiParamData("friendIds", friendIds, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Returns leaderboard data that only contains entries of players that are game friends with the current user.
     * <p/>
     * The GameSparks platform will attempt to return players both ahead and behind the current player, where data is available.
     * <p/>
     * The entry count defines how many player should be returned both ahead and behind. The numer of results may vary if there are not enough friends either
     * ahead or behind.
     * 
     * @param challengeInstanceId The challenge instance to get the leaderboard data for
     * @param entryCount The maximum number of records to return
     * @param friendIds
     * @param leaderboardShortCode The short code of the leaderboard
     * @param offset
     * @param social
     */
    public GSSender socialLeaderboardDataRequest(String challengeInstanceId, Integer entryCount, String[] friendIds, String leaderboardShortCode,
            Integer offset, boolean social) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".SocialLeaderboardDataRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("entryCount", entryCount, apiParamData);
        setApiParamData("friendIds", friendIds, apiParamData);
        setApiParamData("leaderboardShortCode", leaderboardShortCode, apiParamData);
        setApiParamData("offset", offset, apiParamData);
        setApiParamData("social", social, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Allows a Twitter account to be used as an authentication mechanism.
     * <p/>
     * Once authenticated the platform can determine the current players details from the Twitter platform and store them within GameSparks.
     * <p/>
     * GameSparks will determine the player's friends and whether any of them are currently registered with the game.
     * <p/>
     * If the Twitter user is already linked to a player, the current session will switch to the linked player.
     * <p/>
     * If the current player has previously created an account using either DeviceAuthentictionRequest or RegistrationRequest AND the Twitter user is not
     * already registered with the game, the Twitter user will be linked to the current player.
     * <p/>
     * If the current player has not authenticated and the Twitter user is not known, a new player will be created using the Twitter details and the session
     * will be authenticated against the new player.
     * <p/>
     * If the Twitter user is already known, the session will switch to being the previously created user.
     * 
     * @param accessSecret The accessSecret is obtained at the same time as the accessToken, and is required to sign requests to Twitter's services that require
     *            the accessToken.
     * @param accessToken The accessToken represents a player's permission to share access to their account with your application.
     */
    public GSSender twitterConnectRequest(String accessSecret, String accessToken) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".TwitterConnectRequest", apiParamData);
        setApiParamData("accessSecret", accessSecret, apiParamData);
        setApiParamData("accessToken", accessToken, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Processes a transaction receipt from a windows store purchase.
     * <p/>
     * The GameSparks platform will validate the receipt using the signature embedded in the xml. The Id in the xml will be recorded and the request will be
     * rejected if the Id has previously been processed, this prevents replay attacks.
     * <p/>
     * Once verified, the players account will be credited with the Virtual Good, or Virtual Currency the purchase contains. The virtual good will be looked up
     * by matching the productId in the xml with the 'WP8 Product ID' configured against the virtual good.
     * 
     * @param currencyCode
     * @param receipt The xml reciept returned from the windows phone 8 store
     * @param subUnitPrice
     */
    public GSSender windowsBuyGoodsRequest(String currencyCode, String receipt, Long subUnitPrice) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".WindowsBuyGoodsRequest", apiParamData);
        setApiParamData("currencyCode", currencyCode, apiParamData);
        setApiParamData("receipt", receipt, apiParamData);
        setApiParamData("subUnitPrice", subUnitPrice, apiParamData);
        return getSender(apiParamData);
    }

    /**
     * Withdraws a challenge previously issued by the current player.
     * <p/>
     * This can only be done while the challenge is in the ISSUED state. Once it's been accepted the challenge can not be withdrawn.
     * 
     * @param challengeInstanceId The ID of the challenge
     * @param message An optional message to send with the challenge
     */
    public GSSender withdrawChallengeRequest(String challengeInstanceId, String message) {
        Map<String, Object> apiParamData = new HashMap<String, Object>();
        setApiParamData("@class", ".WithdrawChallengeRequest", apiParamData);
        setApiParamData("challengeInstanceId", challengeInstanceId, apiParamData);
        setApiParamData("message", message, apiParamData);
        return getSender(apiParamData);
    }

    private void setApiParamData(String key, Object value, Map<String, Object> data) {
        if (value != null) {
            if (value instanceof Date) {
                data.put(key, convertDateToString((Date) value));
            } else if (value instanceof String[]) {
                List<String> values = new ArrayList<String>();
                for (String string : (String[]) value) {
                    values.add(string);
                }
                data.put(key, values);
            } else {
                data.put(key, value);
            }
        }
    }

    private String convertDateToString(Date date) {
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'");
        return formatter.format(date);
    }

}
